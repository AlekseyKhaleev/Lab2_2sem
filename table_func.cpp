/**********************************************************************************************************************
* Данный модуль содержит описания функций, предназначенных для работы с таблицей (создание, инициализация, вывод)
***********************************************************************************************************************/

/* Подключение модулей */
#include "table_func.h"
#include "definitions.h"
#include "structs.h"
#include "print_func.h"
#include "draw_func.h"
#include <iostream>
#include <map>
#include <termios.h>
#include <unistd.h>

/* Функция вызова исключения связанного с выделением памяти для передачи в set_new_handler() */
void NewError() {
    throw std::bad_alloc();
}

int UserKey() {
    /*****************************************************************************************************************
    * Цель: Считывание кода нажатой клавиши в терминале без промежуточной буферизации
    * Исходные данные:
    * Результат: функция возвращает целое число соответствующее коду нажатой клавиши
    * Вызываемые модули: <termios.h>, <unistd.h>
    * Описание алгоритма:
    * 1) С помощью модуля termios.h объявляются структуры для хранения состояния терминала:
    *       - oldt до считывания нажатия клавиши
    *       - newt во время считывания нажатия клавиши
    * 2) Объявляются целочисленные переменные и массив:
    *   - key_buffer целочисленный массив для хранения кода считанной клавиши (из-за привязки к ESC-последовательностям
    *   управляющие клавиши могут возвращать не единственное целое число (код символа), а серию таких чисел).
    *   Размер массива равен 10, чтобы обеспечить "запас" и избежать обращения по несуществующему индексу.
    *   - buffer_index вспомогательная переменная для обхода массива key_buffer в цикле.
    *   - key_code переменная для хранения обработанного кода считанной клавиши.
    * 3) В структуру oldt записывается текущее состояние терминала, это позволит восстановить исходное состояние
    * терминала после завершения необходимых операций, также состояние дублируется в структуру newt.
    * 4) В структуре newt отключаются флаги "каноничный" и "эхо", это необходимо для обеспечения не каноничного ввода
    * (без буферизации, редактирования).
    * 5) С помощью структуры newt применяется новый режим (состояние) терминала.
    * 6) C помощью функции getchar() считывается нажатие клавиши клавиатуры, результат приводится к типу int
    * и записывается в массив key_buffer под индексом 0.
    * 7) Производится обработка полученного значения:
    *   - если полученное целое значение равно 27, то возможны 2 варианта:
    *     1. Считана клавиша ESC, значение записано в массив.
    *     2. Считана управляющая клавиша, первое число из серии возвращаемых значений записано в массив.
    *   Для определения нажатой клавиши с помощью цикла производится попытка считать все оставшиеся числа серии
    *   и записать их в массив key_buffer. Для продвижения по массиву в цикле используется переменная-индекс
    *   buffer_index, начальное значение которого равно 1. Отличие от 1 индекса после завершения цикла является
    *   маркером считывания управляющей клавиши. В данной программе используются только 2 управляющие клавиши,
    *   не считая ESC: Up и Down, серии возвращаемых значений которых отличаются третьими элементами, равными
    *   соответственно 65 и 66. В связи с этим свойством, в случае отличия от 1 индекса buffer_index в переменную
    *   key_code записывается значение элемента key_buffer с индексом 2. В противном случае записывается значение
    *   элемента key_buffer с индексом 0.
    * 8) С помощью сохраненного в структуре oldt состояния терминала восстанавливаются исходные параметры.
    * 9) Функция возвращает обработанный целочисленный код клавиши, сохраненный в переменной key_code.
    // Дата: 09 / 03 / 2022 Версия 1.01
    // Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    // Исправления: нет
    *****************************************************************************************************************/
    struct termios oldt{}, newt{};                          // структуры для хранения состояния терминала
    int key_code, buffer_index{1}, key_buffer[KEY_BUF_LEN]; // Переменные и массив, необходимые для работы модуля
    tcgetattr(STDIN_FILENO, &oldt);            // Сохранение исходного состояния терминала
    newt = oldt;                                           // Копирование состояния терминала для дальнейшей работы
    newt.c_lflag &= ~(ICANON | ECHO);                      // Отключение флагов "каноничный" и "эхо"
    tcsetattr(STDIN_FILENO, TCSANOW, &newt); // Применение новых параметров терминала
    key_buffer[0] = getchar(); // Считывание нажатия клавиши клавиатуры

    // Блок обработки, проверка на получение управляющей клавиши, сохранение целочисленного кода нажатой клавиши
    if (key_buffer[0] == 27) {
        newt.c_cc[VMIN] = 0;
        tcsetattr(0, TCSANOW, &newt);
        while ((key_buffer[buffer_index] = getchar()) > 0) {
            ++buffer_index;
            if (buffer_index >= KEY_BUF_LEN) break;
        }
        clearerr(stdin);
    }
    if (buffer_index > 1) {
        key_code = key_buffer[2];
    } else
        key_code = key_buffer[0];

    /* Восстановление исходных параметров терминала */
    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
    return key_code; // Возвращение целочисленного кода нажатой клавиши, завершение работы модуля
}

void PrintTable(struct PC ParkContent[], int rows_request, int row_number) {
    /****************************************************************************************************************
    * Цель: Печать указанного количества строк таблицы, начиная с указанной строки
    * Исходные данные:
    *      ParkContent  - массив структур, составляющих парк ПК, каждый элемент массива/структура - строка таблицы
    *      rows_request - запрошенное количество строк для вывода
    *      row_number   - номер строки, с которой начинается вывод
    * Результат: Таблица выведена согласно запроса
    * Вызываемые модули: "structs.h", "definitions.h"
    * Описание алгоритма:
    * 1) С помощью логического выражения определяется необходимое количество строк для вывода. Количество выводимых
    *  строк не может быть больше чем вмещает таблица, отрисованная на экране:
    *  - если запрошенное количество строк на вывод больше максимального, будет выведено максимальное количество строк
    *  Определенное значение присваивается переменной total_rows
    * 2) В цикле с помощью инкремента изменяются значения двух переменных:
    *   i : от 0 до определенного количества строк total_rows (не включительно)
    *   j : от row_number до завершения цикла
    * 3) На каждой итерации цикла для элемента массива структур ParkContent с индексом j осуществляется вызов метода
    * .print с аргументом i. Такая операция приводит к выводу данных ПК с номером [j] в i-той строке таблицы.
    * Дата: 15 / 05 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    ****************************************************************************************************************/
    int total_rows = rows_request > MAX_ROWS ? MAX_ROWS : rows_request; // количество строк с учетом ограничений
    for (int i = 0, j = row_number; i < total_rows; i++, j++) {
        ParkContent[j].print(i);
    }
}

int CreateTable(char *argv[], std::fstream &table_out, int rows_request) {
    /****************************************************************************************************************
    * Цель: Запись в бинарный файл данных таблицы, введенных пользователем
    * Исходные данные:
    *      argv          - массив аргументов командной строки, с которыми была запущена программа
    *      table_out     - дескриптор файла для записи введенных данных таблицы
    *      rows_request  - запрошенное количество строк для записи (Также содержится в массиве аргументов argv, но
    *      в виде С-строки. Так как тип уже приводится к int в процессе обработки корректности аргументов, целесообразно
    *      использовать приведенное значение, для избежания дублирования кода)
    * Результат:
    *   - введены и записаны в бинарный файл данные таблицы
    *   - функция возвращает номер первой значащей строки, отображаемой в данный момент (порядковый номер ПК)
    * Вызываемые модули: "structs.h", "definitions.h", <fstream>, <iostream>
    * Описание алгоритма:
    * 1) С помощью функции CustomizeTerminal применяются новые настройки терминала, необходимые для корректной работы
    * программы
    * 2) С помощью функции PrintHeader выводится заголовок отображаемой страницы
    * 3) С помощью функции DrawTable выводится пустой шаблон таблицы
    * 4) Применяются настройки для отлавливания ошибок, связанных с выделением памяти
    * 5) Объявляется и инициализируется начальным значением 1 переменная row_number, соответствующая номеру первой
    * значащей строки, отображаемой в данный момент (порядковый номер ПК)
    * 6) В файл, соответствующий дескриптору table_out
    *   i : от 0 до определенного количества строк total_rows (не включительно)
    *   j : от row_number до завершения цикла
    * 3) На каждой итерации цикла для элемента массива структур ParkContent с индексом j осуществляется вызов метода
    * .print с аргументом i. Такая операция приводит к выводу данных ПК с номером [j] в i-той строке таблицы.
    * Дата: 15 / 05 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    ****************************************************************************************************************/
    CustomizeTerminal(F_BLACK, B_WHITE);
    PrintHeader(argv);
    DrawTable();
    errno = 0;  // Переменная модуля errno.h, хранящая целочисленный код последней ошибки. 0 - отсутствие ошибок
    std::set_new_handler(NewError); // Назначение функции, которая будет вызвана при получении ошибки выделения памяти
    int row_number = 1;
    try {
        table_out.write((char *) &CORRECT_BIT, sizeof(CORRECT_BIT));
        table_out.write((char *) &rows_request, sizeof(int));
        auto ParkUpdate = new PC[rows_request];
        for (int i = 0; i < rows_request; i++) {
            if (i < MAX_ROWS) {
                ParkUpdate[i].set(i+1, i);
                table_out.write((char *) &ParkUpdate[i], sizeof(struct PC));
            } else {
                DrawTable();
                PrintTable(ParkUpdate, i - 1, row_number);
                ParkUpdate[i].set(i+1, MAX_ROWS - 1);
                table_out.write((char *) &ParkUpdate[i], sizeof(struct PC));
                row_number++;
            }
        }
        std::cout << std::endl;
        delete[] ParkUpdate;
    } catch (std::exception &e) { // Обработка исключения, связанного с выделением динамической памяти
        perror("Memory allocation error");
    }
    row_number--;
    return row_number;
}

void ViewTable(char *argv[], std::fstream &table_in, int rows_request, int row_number) {
    errno = 0;  // Переменная модуля errno.h, хранящая целочисленный код последней ошибки. 0 - отсутствие ошибок
    std::set_new_handler(NewError); // Назначение функции, которая будет вызвана при получении ошибки выделения памяти
    try {
        /* последовательный контейнер из двух элементов, соответствующих количеству прочитанных строк в файле
         * и действительному количеству строк в файле*/

        /* Действительное количество строк */
        int real_rows;
        table_in.seekg(sizeof(CORRECT_BIT));
        table_in.read((char *) &real_rows, sizeof(int));
        int rows_to_print = rows_request < real_rows? rows_request:real_rows;
        auto *ParkContent = new PC[rows_to_print];
        for (int i = 0; i < rows_to_print; i++) {
            table_in.read((char *) &ParkContent[i], sizeof(struct PC));
        }
        GenerateTablePage(ParkContent,argv,rows_to_print,real_rows,row_number);
        int mark = true; // флаг-индикатор продолжения/завершения программы
        while (mark) { // бесконечный цикл считывания клавиш
            switch (UserKey()) { // считывание кода клавиши введенной пользователем в режиме "реального времени"
                /* Клавиша ESC завершит цикл считывания клавиш */
                case Escape: {
                    mark = false;
                    break;
                }
                case Up: {
                    if (row_number > 0) {
                        row_number--;
                        GenerateTablePage(ParkContent,argv,rows_to_print,real_rows,row_number);
                    }
                    break;
                }
                case Down: {
                    if ((row_number <= rows_to_print - MAX_ROWS_FR) && (rows_to_print > MAX_ROWS_FR)) {
                        row_number++;
                        GenerateTablePage(ParkContent,argv,rows_to_print,real_rows,row_number);
                    }
                    break;
                }
                case Help: {
                    PrintHelpScreen("help_prog"); // Вывод справочного экрана
                    int h_mark = true; // флаг-индикатор продолжения/завершения показа справочного экрана
                    while (h_mark) { // бесконечный цикл считывания клавиш
                        switch (UserKey()) { // считывание кода клавиши введенной пользователем в режиме "реального времени"
                            /* Клавиша ESC завершит цикл считывания клавиш как в режиме справки, так и в основном цикле
                             * и приведет в последствии к завершению программы*/
                            case Escape: {
                                h_mark = false;
                                mark = false;
                                break;
                            }
                                /* Клавиша r завершит цикл считывания клавиш в режиме справки, просмотр текста продолжится
                                 * с экрана на котором была вызвана справка */
                            case Return: {
                                GenerateTablePage(ParkContent,argv,rows_to_print,real_rows,row_number);
                                h_mark = false;
                                break;
                            }
                            default:
                                break;  // игнорирование любых клавиш, поведение которых неопределено
                        }
                    }
                    break;
                }
            }
        }
        delete[] ParkContent;
    } catch (std::exception &e) { // Обработка исключения, связанного с выделением динамической памяти
        perror("Memory allocation error");
    }
}

void GenerateTablePage(struct PC ParkContent[], char* argv[], int rows_to_print, int real_rows, int row_number){
    CustomizeTerminal(F_BLACK, B_WHITE);
    PrintHeader(argv);
    DrawTable();
    PrintTable(ParkContent, rows_to_print, row_number);
    PrintFooter(argv, rows_to_print,real_rows);
}

